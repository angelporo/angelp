<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>react中高阶组件的使用以及技巧 | 会上树的猪</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="react,react-native,高阶组件," />
  

  <meta name="description" content="写的不错, 先转载, 之后在写自己的学习成果">
<meta name="keywords" content="react,react-native,高阶组件">
<meta property="og:type" content="article">
<meta property="og:title" content="react中高阶组件的使用以及技巧">
<meta property="og:url" content="http://angely.me/2017/07/24/react中高阶组件的使用以及技巧/index.html">
<meta property="og:site_name" content="会上树的猪">
<meta property="og:description" content="写的不错, 先转载, 之后在写自己的学习成果">
<meta property="og:image" content="http://angely.me/2017/07/24/react中高阶组件的使用以及技巧/react-hoc.png">
<meta property="og:image" content="http://angely.me/2017/07/24/react中高阶组件的使用以及技巧/hoc1.png">
<meta property="og:image" content="http://angely.me/2017/07/24/react中高阶组件的使用以及技巧/hoc2.png">
<meta property="og:updated_time" content="2020-03-23T02:21:44.124Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="react中高阶组件的使用以及技巧">
<meta name="twitter:description" content="写的不错, 先转载, 之后在写自己的学习成果">
<meta name="twitter:image" content="http://angely.me/2017/07/24/react中高阶组件的使用以及技巧/react-hoc.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#高阶组件和高阶函数的定义"><span class="toc-text">高阶组件和高阶函数的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现一个简单的高阶组件"><span class="toc-text">实现一个简单的高阶组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高阶组件的进阶用法"><span class="toc-text">高阶组件的进阶用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-组件参数"><span class="toc-text">1. 组件参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HOC的使用范围对比"><span class="toc-text">HOC的使用范围对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HOC-的具体实践"><span class="toc-text">HOC 的具体实践</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-react中高阶组件的使用以及技巧" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">react中高阶组件的使用以及技巧</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.07.24</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>li yuan</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <img src="/2017/07/24/react中高阶组件的使用以及技巧/react-hoc.png" alt="高阶组件抽象表单功能而非UI" title="高阶组件抽象表单功能而非UI">
<p><a href="https://zhuanlan.zhihu.com/p/27434557" target="_blank" rel="external">写的不错, 先转载, 之后在写自己的学习成果</a></p>
<a id="more"></a>
<p>这篇文章完全就是为了更好的理解React中的高阶组件,</p>
<h3 id="高阶组件和高阶函数的定义"><a href="#高阶组件和高阶函数的定义" class="headerlink" title="高阶组件和高阶函数的定义"></a>高阶组件和高阶函数的定义</h3><p>高阶函数<br>接受函数作为参数, 或者输入另一个函数的一类函数,  被称为高阶函数.</p>
<p>对于高阶组件<br>接受一个组件作为参数,  这个组件,  可以是纯函数组件也可以<code>class extends Component</code>组件. 输出一个新的React组件的组件,  更通俗地描述为，<strong>高阶组件</strong>通过包裹（wrapped）被传入的React组件，经过一系列处理，最终返回一个相对增强（enhanced）的React<br>高阶组件是<code>React</code>中复用组件逻辑的一种进阶技巧,  他是一种技巧,  并不是什么特别高大上的一种API,  而是一种<code>React</code>组件设计理念,  众多的React库已经表明了, 这一设计的价值.例如<code>React-Redux</code></p>
<h3 id="实现一个简单的高阶组件"><a href="#实现一个简单的高阶组件" class="headerlink" title="实现一个简单的高阶组件"></a>实现一个简单的高阶组件</h3><p>下面我们来实现一个简单的高阶组件(函数),  它接受一个React组件,  然后返回一个增强版的组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">WithHeader</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render () &#123;</div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"demo-header"</span>&gt;</span></div><div class="line">            这里是标题</div><div class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家可以看出这个组件的效果,  就是给传入的组件添加了一个标题,  但是这个效果我们也可以用其他的方法来实现, 下面说为什么这样设计,  也就是高阶函数的设计优点.</p>
<p>接下来, 我们来使用这个高阶组件,  用来强化之前被作为参数传入的组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@WithHeader</div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        这是一个普通组件</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里使用了ES7里的<code>decorator</code>，来提升写法上的优雅，但是实际上它只是一个语法糖，下面这种写法也是可以的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EnhanceDemo = WithHeader(Demoe);</div></pre></td></tr></table></figure></p>
<p>随后，观察React组件树发生了什么变化，如图所示，可以发现Demo组件被HOC组件包裹起来了，符合了高阶组件的预期，即组件是层层包裹起来的，如同洋葱一样。</p>
<img src="/2017/07/24/react中高阶组件的使用以及技巧/hoc1.png" alt="被强化的高阶组件" title="被强化的高阶组件">
<p>因为高阶组件最终<code>return</code>了一个明为<code>HOC</code>的组件,<br>所以在多次使用高阶组件之后, 在调试的时候会看到一大推<code>HOC</code>组件, 所以要做一个点小的优化, 就是在使用高阶组件包裹后,  应该保留原有的名称,  这样调试才会有好.</p>
<p>我们改写一些上面的高阶组件代码, 增加了<code>getDisplayName</code>函数以及静态属性<code>displayName</code>, 这个静态属性就是为了查看组件名称的. 这是在去观察呢<code>DOM Tree</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">component</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> component.displayName || component.name || <span class="string">'Component'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"> WrappedComponent </span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></div><div class="line">    render () &#123;</div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">          <span class="tag">&lt;<span class="name">div</span>&gt;</span>这里是标题<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">WrappedComponent</span> &#123; <span class="attr">...this.props</span>&#125; /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样,  给每个需要增强的组件添加一个静态属性查看组件的名字</p>
<img src="/2017/07/24/react中高阶组件的使用以及技巧/hoc2.png" alt="添加静态名称属性" title="添加静态名称属性">
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>上面这个例子里高阶组件只做了一件事, 就是给传入组件添加一个标题样式 ,  这个组件可以是任何一个添加次逻辑的组件上面,  值需要被高阶组件装饰即可.<br>由此可以看出, 高阶组件的主要功能是封装并抽离组件的通用逻辑, 让此部分逻辑在组件之间更好的复用.</p>
</blockquote>
<h3 id="高阶组件的进阶用法"><a href="#高阶组件的进阶用法" class="headerlink" title="高阶组件的进阶用法"></a>高阶组件的进阶用法</h3><h4 id="1-组件参数"><a href="#1-组件参数" class="headerlink" title="1. 组件参数"></a>1. 组件参数</h4><p>还是上面这个例子为例,  词高阶函数仅仅只是展示了标题内容<code>这里是标题</code>这个名称, 但是为了更好的抽象, 标题内容可以作为参数来获取, 如下面方式调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果传入参数, 则传入的参数将作为组件的标题呈现</span></div><div class="line">@WithHeader(<span class="string">'Demo'</span>)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="comment">//...</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WithHeader</code>需要改写层如下形式, 它接受一个参数, 然后反悔一个高阶组件(函数).<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">title</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">      render () &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">          <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"demoe-header"</span>&gt;</span></div><div class="line">              &#123; title ? title : '这里是标题'&#125;</div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">WrappedComponent</span> &#123; <span class="attr">...this.props</span> &#125; /&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        );</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配合上es6写法可以更加简介<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">title</span>) =&gt;</span> (WrappedComponent) =&gt; <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"demoe-header"</span>&gt;</span></div><div class="line">          &#123; title ? title : '这里是标题'&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">WrappedComponent</span> &#123; <span class="attr">...this.props</span> &#125; /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyComponent(<span class="string">'参数传入标图'</span>)(Demo);</div></pre></td></tr></table></figure></p>
<p>上面这个高阶组件能够对<code>WrappedComponent</code>组件内的<code>props</code>进行操作, 提取<code>WrappedComponent</code>中的<code>state</code>以及使用其他原属来包裹<code>WrappedComponent</code>。<code>Props Proxy</code> 作为一层代理，会发生隔离，因此传入 <code>WrappedComponent</code> 的 <code>ref</code> 将无法访问到其本身(!这里我还没有理解为什么)，需在 <code>Props Proxy</code> 内完成中转，具体可参考以下代码，<code>react-redux</code> 也是这样实现的。</p>
<p>进阶:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">component</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> component.displayName || component.name || <span class="string">'Component'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> ppHOC = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="comment">// 添加静态显示名称属性</span></div><div class="line">  <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;WrappedComponent.displayName&#125;</span>)`</span>;</div><div class="line">  getWrappedInstance () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.wrappedInstance;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 实现ref的访问</span></div><div class="line">  setWrappedInstance (ref) &#123;</div><div class="line">    <span class="keyword">this</span>.wrappedInstance = ref;</div><div class="line">  &#125;</div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;WrappedComponent</div><div class="line">          &#123;</div><div class="line">          // 注意这里是一个对象</div><div class="line">          ...this.props</div><div class="line">        ref: this.setWrappedInstance.bind(this)</div><div class="line">          &#125;</div><div class="line">        /&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@ppHOC</div><div class="line">class Example extends React.Component &#123;</div><div class="line">  static displayName = 'Example';</div><div class="line">  handleClick() &#123; ... &#125;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">class App extends React.Component &#123;</div><div class="line">  handleClick() &#123;</div><div class="line">    this.refs.example.getWrappedInstance().handleClick();</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;按钮&lt;/button&gt;</div><div class="line">        &lt;Example ref="example" /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>归纳:</p>
<h4 id="HOC的使用范围对比"><a href="#HOC的使用范围对比" class="headerlink" title="HOC的使用范围对比"></a>HOC的使用范围对比</h4><p>HOC 范式 compose(render)(state) 与父组件（Parent Component）的范式 render(render(state))，如果完全利用 HOC 来实现 React 的 implement，将操作与 view 分离，也未尝不可，但却不优雅。HOC 本质上是统一功能抽象，强调逻辑与 UI 分离。但在实际开发中，前端无法逃离 DOM ，而逻辑与 DOM 的相关性主要呈现 3 种关联形式：</p>
<ul>
<li>与 DOM 相关，建议使用父组件，类似于原生 HTML 编写</li>
<li>与 DOM 不相关，如校验、权限、请求发送、数据转换这类，通过数据变化间接控制 DOM，可以使用 HOC 抽象</li>
<li>交叉的部分，DOM 相关，但可以做到完全内聚，即这些 DOM 不会和外部有关联，均可</li>
</ul>
<p>HOC 适合做 DOM 不相关又是多个组件共性的操作。如 Form 中，validator 校验操作就是纯数据操作的，放到了 HOC 中。但 validator 信息没有放到 HOC 中。但如果能把 Error 信息展示这些逻辑能够完全隔离，也可以放到 HOC 中（可结合下一小节 Form 具体实践详细了解）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">connect(<span class="function"><span class="params">props</span> =&gt;</span> (&#123;</div><div class="line">  <span class="attr">usersFetch</span>: <span class="string">`/users?status=<span class="subst">$&#123;props.status&#125;</span>&amp;page=<span class="subst">$&#123;props.page&#125;</span>`</span>,</div><div class="line">  <span class="attr">userStatsFetch</span>: &#123; <span class="attr">url</span>: <span class="string">`/users/stats`</span>, <span class="attr">force</span>: <span class="literal">true</span> &#125;</div><div class="line">&#125;))(UsersList)</div></pre></td></tr></table></figure>
<h3 id="HOC-的具体实践"><a href="#HOC-的具体实践" class="headerlink" title="HOC 的具体实践"></a>HOC 的具体实践</h3><p>HOC 在真实场景下的运行非常多，之前笔者在 基于Decorator的组件扩展实践 一文中也提过使用高阶组件将更细粒度的组件组合成 Selector 与 Search。结合精读文章，这次让我们通过 Form 组件的抽象来表现 HOC 具有的良好扩展机制。</p>
<p>Form 中会包含各种不同的组件, 常用的有Input, Selector, Chackbox, 等等, 也会有根据业务需求加入自定义组件. form 灵活多变,  从功能上面, 表单验证可能未单组件校验, 也可能为全表单校验, 可能未常规校验, 比如: 非空, 输入限制, 也可能需要与服务端配合, 甚至需要根据业务特点进行定制, 从UI上看, 检验结果显示的位置, 可能在组件下方, 也可能在组件上方.</p>
<p>如果直接漏写form表单, 无意识机械而又重复的, 将<code>Form</code>中组件的<code>validator</code>, 把value, validator 产生的error信息储存到<code>state</code>或<code>redux store</code>中, 然后在<code>view</code>层完成显示. 这样的具体操作可能都是相同的, 可以进行复用, 只是我们面对的是不同的组件, 不同的validator, 不同的<code>view</code>而已. 对于Form而言, 既要满足通用, 又要满足部分个性化的需求, 以往单纯的配置话只会让使用瑜伽繁琐, 我们只需要休想的是Form功能而非UI,  因此通过HOC正对Form的功能进行提取就成为了必然.</p>
<p>至于 HOC 在 Form 上的具体实现，首先将表单中的组件（Input、Selector…）与相应 validator 与组件值回调函数名（trigger）传入 Decorator，将 validator 与 trigger 相绑定。Decorator 完成<br>了各种不同组件与 From 内置 Store 间 value 的传递、校验功能的抽象，即精读文章中提到 Props Proxy 方式的其中两种作用：提取state 与 操作props<br><a href="https://github.com/react-component/form" target="_blank" rel="external">form库</a>的实现方式就是这种<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createForm &#125; <span class="keyword">from</span> <span class="string">'rc-form'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  submit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.props.form.validateFields(<span class="function">(<span class="params">error, value</span>) =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(error, value);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; getFieldError, getFieldDecorator &#125; = <span class="keyword">this</span>.props.form;</div><div class="line">    <span class="keyword">const</span> errors = getFieldError(<span class="string">'required'</span>);</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        &#123;getFieldDecorator('required', &#123;</div><div class="line">          rules: [&#123; required: true &#125;],</div><div class="line">        &#125;)(<span class="tag">&lt;<span class="name">Input</span> /&gt;</span>)&#125;</div><div class="line">        &#123;errors ? errors.join(',') : null&#125;</div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.submit&#125;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> createForm()(Form);</div></pre></td></tr></table></figure></p>
<p>觉得有必要说一下高阶函数和函数传参的区别,  同样,  函数传参也同样能达到效果, 为什么高阶函数就使用起来很方便</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/27434557" target="_blank" rel="external">参考文章</a><br><a href="https://yq.aliyun.com/articles/149115?utm_content=m_27063" target="_blank" rel="external">参考文章</a></p>
</blockquote>

    
  </div>

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/07/08/react中setState的使用/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/07/25/mac下更新node和npm/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '277317290454635afa73',
  clientSecret: '78223c859304da5e8d71bfce136d436c6ff95c37',
  repo: 'blog-comment',
  owner: 'forsigner',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['forsigner'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
